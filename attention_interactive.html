<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oniris: Interactive Attention Explanation</title>
    <!-- D3.js library -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- MathJax for LaTeX rendering -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true
        },
        svg: { fontCache: 'global' },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
        },
        startup: {
          ready: () => {
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <style>
        /* Basic styles for the page and visualization */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f9fafb; /* gray-50 */
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        #main-container {
            width: 98vw;
            height: 98vh;
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
        }
        .visualization-container {
            flex: 1;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        svg {
            user-select: none;
            -webkit-user-select: none;
            display: block;
            overflow: visible;
            background-color: white;
            border: 1px solid #e5e7eb; /* gray-200 */
            border-radius: 0.75rem; /* Larger border radius */
            width: 100%;
            height: 100%;
        }
        /* Box styles for the main animation */
        .box {
            stroke-width: 1.5; 
            cursor: default;
            transition: fill 0.2s ease-in-out, stroke 0.2s ease-in-out, opacity 0.5s ease-in-out;
        }
        .box.clean {
            stroke: #38bdf8; /* sky-400 */
            fill: #e0f2fe;   /* sky-50 */
        }
        .box.noisy {
            stroke: #2dd4bf; /* teal-400 */
            fill: #ccfbf1;   /* teal-50 */
        }
        .box.noisy:not(.faded-out) {
            cursor: pointer;
        }
        .box:not(.faded-out):hover {
            fill: #f472b6; /* pink-400 */
        }
        .box.related-highlight {
            fill: #f472b6; /* pink-400, same as hover */
        }
        /* Connection line styles */
        .connection {
            stroke-width: 2; 
            transition: opacity 0.5s ease-in-out, stroke 0.2s ease-in-out, stroke-width 0.2s ease-in-out;
            opacity: 0.8;
        }
        .connection.dimmed {
            opacity: 0.05;
        }
        .connection.highlighted {
            opacity: 1;
            stroke: #ec4899; /* pink-500 */
            stroke-width: 3.5; /* Thicker highlight */
        }
        .connection.default-gray {
            stroke: #6b7280; /* gray-500 */
        }
        /* MathJax label container styles */
        .math-host-span {
            font-size: 16px;
            text-align: center;
            padding: 2px;
            transition: color 0.2s ease-in-out, opacity 0.5s ease-in-out;
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            color: #374151; /* gray-700 */
        }
        foreignObject {
            transition: opacity 0.5s ease-in-out;
        }

        /* Styles for the mask visualization */
        .mask-cell {
            stroke: #e5e7eb; /* gray-200 */
            stroke-width: 0.5;
            transition: fill 0.2s ease-in-out, opacity 0.8s ease-in-out, stroke 0.2s ease-in-out, stroke-width 0.2s ease-in-out;
        }
        .mask-cell.on {
            fill: var(--cell-color, #38bdf8); /* Use CSS variable for dynamic color */
        }
        .mask-cell.off {
            fill: transparent; /* Make non-connected cells transparent */
        }
        .mask-cell.highlighted {
            stroke: #ec4899; /* pink-500 */
            stroke-width: 2;
        }
        .mask-cell.highlighted.on {
            fill: #f472b6; /* pink-400 on highlight */
        }
        .axis-label {
            font-size: 18px;
            font-weight: 500;
            fill: #495137; /* gray-700 */
        }
        .mask-tick .math-host-span {
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="main-container">
        <div class="visualization-container" id="animation-container">
            <svg id="visualization"></svg>
        </div>
        <div class="visualization-container" id="mask-container">
            <svg id="mask-visualization"></svg>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- D3 Setup and Constants ---
            const svgAnim = d3.select('#visualization');
            const svgMask = d3.select('#mask-visualization');
            const N_FRAMES_DEFAULT = 5; 

            // Animation constants
            const BOX_SIZE = 60;
            const BOX_SPACING = 35;
            const ROW_SPACING = 300;
            const ANIM_PADDING = 80;
            const LABEL_FO_WIDTH = 80;
            const LABEL_FO_HEIGHT = 40;
            const LABEL_OFFSET_Y_TOP = LABEL_FO_HEIGHT + 15;
            const LABEL_OFFSET_Y_BOTTOM = 15;
            
            // Mask constants
            const MASK_PADDING = 80;
            const MASK_LABEL_OFFSET = 60;
            const MASK_SVG_SIZE = 800; // Fixed size for simplicity
            const MASK_GRID_SIZE = MASK_SVG_SIZE - MASK_PADDING * 2 - MASK_LABEL_OFFSET;

            // General transition constants
            const FADE_DURATION = 600;
            const MOVE_DURATION = 800;
            const STAGGER_DELAY = 100;

            // --- State Management ---
            let isAnimating = false;
            let isAnimationComplete = false;
            let lastAnimatedIndex = null;
            let currentNFrames = -1;
            let boxesData = []; 

            // --- Groups for SVG layers ---
            const linesGroup = svgAnim.append('g').attr('id', 'lines-group');
            const boxesGroup = svgAnim.append('g').attr('id', 'boxes-group');
            const animLabelsGroup = svgAnim.append('g').attr('id', 'labels-group');
            const maskGridGroup = svgMask.append('g').attr('id', 'mask-grid-group');
            const maskLabelsGroup = svgMask.append('g').attr('id', 'mask-labels-group');

            // --- Connectivity Logic ---
            const are_connected_training = (q_idx, k_idx, n) => {
                const q_is_clean = q_idx < n;
                const k_is_clean = k_idx < n;
                const q_eff = q_idx % n;
                const k_eff = k_idx % n;

                if (q_is_clean && k_is_clean) return q_eff >= k_eff;
                if (!q_is_clean && k_is_clean) return q_eff > k_eff;
                if (!q_is_clean && !k_is_clean) return q_eff === k_eff;
                return false;
            };

            const are_connected_inference_anim = (q_idx, k_idx, n, target_eff) => {
                const q_is_clean = q_idx < n;
                const k_is_clean = k_idx < n;
                const q_eff = q_idx % n;
                const k_eff = k_idx % n;
                if (!q_is_clean && q_eff === target_eff) {
                    if (k_is_clean && target_eff > k_eff) return true;
                    if (!k_is_clean && k_eff === target_eff) return true;
                }
                return false;
            };

            // --- Color Palette ---
            const getColor = d3.scaleSequential(d3.interpolateCool).domain([0, N_FRAMES_DEFAULT]);

            // --- Main Drawing Function ---
            function initializeVisualizations() {
                const n_frames = N_FRAMES_DEFAULT;
                currentNFrames = n_frames;
                
                isAnimating = false;
                isAnimationComplete = false;
                lastAnimatedIndex = null;

                drawAttentionAnimation(n_frames);
                drawMaskVisualization('training', { n_frames });
                
                typesetMathJax();
            }

            // --- Attention Animation Drawing ---
            function drawAttentionAnimation(n_frames) {
                const total_frames = n_frames * 2;

                const svgWidth = ANIM_PADDING * 2 + total_frames * BOX_SIZE + (total_frames - 1) * BOX_SPACING;
                const svgHeight = ANIM_PADDING * 2 + ROW_SPACING + BOX_SIZE * 2 + LABEL_OFFSET_Y_TOP + LABEL_OFFSET_Y_BOTTOM;
                svgAnim.attr('viewBox', `0 0 ${svgWidth} ${svgHeight}`);

                const topRowY = ANIM_PADDING + LABEL_OFFSET_Y_TOP;
                const bottomRowY = topRowY + BOX_SIZE + ROW_SPACING;

                boxesData = []; 
                const noisyQueryIndices = [];
                for (let i = 0; i < total_frames; i++) {
                    const isClean = i < n_frames;
                    if (!isClean) noisyQueryIndices.push(i);
                    const eff_idx = i % n_frames;
                    const x_pos = ANIM_PADDING + i * (BOX_SIZE + BOX_SPACING);
                    
                    boxesData.push({ id: `q-${i}`, type: 'q', index: i, eff_idx, isClean, x: x_pos, y: topRowY });
                    boxesData.push({ id: `k-${i}`, type: 'k', index: i, eff_idx, isClean, x: x_pos, y: bottomRowY });
                }

                const linesData = [];
                for (let q_idx = 0; q_idx < total_frames; q_idx++) {
                    for (let k_idx = 0; k_idx < total_frames; k_idx++) {
                        if (are_connected_training(q_idx, k_idx, n_frames)) {
                            linesData.push({
                                id: `line-${q_idx}-${k_idx}`,
                                from_q: q_idx,
                                to_k: k_idx,
                            });
                        }
                    }
                }

                boxesGroup.selectAll('rect.box')
                    .data(boxesData, d => d.id)
                    .join('rect')
                    .attr('class', d => `box ${d.isClean ? 'clean' : 'noisy'}`)
                    .attr('id', d => d.id)
                    .attr('x', d => d.x)
                    .attr('y', d => d.y)
                    .attr('width', BOX_SIZE)
                    .attr('height', BOX_SIZE)
                    .attr('rx', 8) 
                    .attr('ry', 8)
                    .style('opacity', 1)
                    .attr('transform', null)
                    .on('click', handleBoxClick)
                    .on('mouseover', handleMouseOver)
                    .on('mouseout', handleMouseOut);

                animLabelsGroup.selectAll('foreignObject')
                    .data(boxesData, d => d.id)
                    .join('foreignObject')
                    .attr('id', d => `label-${d.id}`)
                    .attr('width', LABEL_FO_WIDTH)
                    .attr('height', LABEL_FO_HEIGHT)
                    .html(d => {
                        const latexPrefix = d.isClean ? "" : "\\tilde";
                        // Use 1-based indexing for labels
                        return `<span class="math-host-span">$${latexPrefix}{${d.type.toUpperCase()}}_{${d.eff_idx + 1}}$</span>`;
                    })
                    .attr('x', d => d.x + BOX_SIZE / 2 - LABEL_FO_WIDTH / 2)
                    .attr('y', d => d.type === 'q' ? d.y - LABEL_OFFSET_Y_TOP : d.y + BOX_SIZE + LABEL_OFFSET_Y_BOTTOM)
                    .style('opacity', 1)
                    .attr('transform', null);

                linesGroup.selectAll('line.connection')
                    .data(linesData, d => d.id)
                    .join('line')
                    .attr('class', 'connection')
                    .attr('data-from-q', d => d.from_q)
                    .attr('data-to-k', d => d.to_k)
                    .attr('x1', d => boxesData.find(b => b.id === `q-${d.from_q}`).x + BOX_SIZE / 2)
                    .attr('y1', d => boxesData.find(b => b.id === `q-${d.from_q}`).y + BOX_SIZE)
                    .attr('x2', d => boxesData.find(b => b.id === `k-${d.to_k}`).x + BOX_SIZE / 2)
                    .attr('y2', d => boxesData.find(b => b.id === `k-${d.to_k}`).y)
                    .style('opacity', 0.8)
                    .attr('stroke', d => {
                        const q_is_clean = d.from_q < n_frames;
                        const k_is_clean = d.to_k < n_frames;
                        if (!q_is_clean && k_is_clean) {
                            const noisyIndex = noisyQueryIndices.indexOf(d.from_q);
                            return getColor(noisyIndex);
                        }
                        return '#6b7280'; // gray-500
                    });
            }

            // --- Mask Visualization Drawing ---
            function drawMaskVisualization(mode, { n_frames, target_eff_idx = 0 }) {
                const size = mode === 'training' ? n_frames * 2 : target_eff_idx + 1;
                
                svgMask.attr('viewBox', `0 0 ${MASK_SVG_SIZE} ${MASK_SVG_SIZE}`);

                const cellSize = MASK_GRID_SIZE / size;

                const maskData = [];
                const labelData = [];

                const noisyQueryIndices = [];
                if (mode === 'training') {
                    for (let i = n_frames; i < n_frames * 2; i++) {
                        noisyQueryIndices.push(i);
                    }
                }

                for (let q = 0; q < size; q++) {
                    for (let k = 0; k < size; k++) {
                        let isOn = false;
                        if (mode === 'training') {
                            isOn = are_connected_training(q, k, n_frames);
                        } else { // inference
                            isOn = q >= k;
                        }

                        let cellColor = 'transparent';
                        if (isOn) {
                            if (mode === 'training') {
                                const q_is_clean = q < n_frames;
                                const k_is_clean = k < n_frames;
                                if (!q_is_clean && k_is_clean) {
                                    const noisyIndex = noisyQueryIndices.indexOf(q);
                                    cellColor = getColor(noisyIndex);
                                } else {
                                    cellColor = '#6b7280'; // gray for clean-clean and noisy-noisy
                                }
                            } else { // inference mode
                                cellColor = '#6b7280';
                            }
                        }

                        maskData.push({
                            q, k, isOn, id: `cell-${q}-${k}`, color: cellColor
                        });
                    }
                    // Labels
                    const isClean = q < n_frames;
                    const eff_idx = q % n_frames;
                    const latexPrefix = (mode === 'training' && !isClean) ? "\\tilde" : "";
                    const label_idx = (mode === 'training') ? eff_idx : q;
                    // Use 1-based indexing and Q/K for matrix labels
                    labelData.push({
                        type: 'q', index: q, label: `$${latexPrefix}{Q}_{${label_idx + 1}}$`
                    });
                    labelData.push({
                        type: 'k', index: q, label: `$${latexPrefix}{K}_{${label_idx + 1}}$`
                    });
                }
                
                // Remove the main axis labels
                maskLabelsGroup.selectAll('.axis-label').remove();

                // Draw Grid
                maskGridGroup.selectAll('rect.mask-cell')
                    .data(maskData, d => d.id)
                    .join(
                        enter => enter.append('rect')
                            .attr('class', d => `mask-cell ${d.isOn ? 'on' : 'off'}`)
                            .attr('x', d => MASK_PADDING + MASK_LABEL_OFFSET + d.k * cellSize)
                            .attr('y', d => MASK_PADDING + d.q * cellSize)
                            .attr('width', cellSize)
                            .attr('height', cellSize)
                            .style('opacity', 0),
                        update => update,
                        exit => exit.transition().duration(FADE_DURATION).style('opacity', 0).remove()
                    )
                    .style('--cell-color', d => d.color) // Set CSS variable for color
                    .transition().duration(FADE_DURATION)
                    .attr('x', d => MASK_PADDING + MASK_LABEL_OFFSET + d.k * cellSize)
                    .attr('y', d => MASK_PADDING + d.q * cellSize)
                    .attr('width', cellSize)
                    .attr('height', cellSize)
                    .attr('class', d => `mask-cell ${d.isOn ? 'on' : 'off'}`)
                    .style('opacity', 1);

                // Draw Tick Labels
                maskLabelsGroup.selectAll('.mask-tick')
                    .data(labelData, d => `${d.type}-${d.index}`)
                    .join(
                        enter => enter.append('foreignObject')
                            .attr('class', 'mask-tick')
                            .attr('width', MASK_LABEL_OFFSET)
                            .attr('height', cellSize)
                            .html(d => `<span class="math-host-span">${d.label}</span>`)
                            .style('opacity', 0),
                        update => update
                            .html(d => `<span class="math-host-span">${d.label}</span>`)
                            .attr('height', cellSize), // FIX: Ensure height is updated on reset
                        exit => exit.transition().duration(FADE_DURATION).style('opacity', 0).remove()
                    )
                    .transition().duration(FADE_DURATION)
                    .attr('x', d => d.type === 'k' ? MASK_PADDING + MASK_LABEL_OFFSET + d.index * cellSize + cellSize / 2 - MASK_LABEL_OFFSET / 2 : MASK_PADDING)
                    .attr('y', d => d.type === 'q' ? MASK_PADDING + d.index * cellSize : MASK_SVG_SIZE - MASK_PADDING - MASK_LABEL_OFFSET / 1.5)
                    .style('opacity', 1);
                
                typesetMathJax();
            }

            // --- Animation Functions ---
            function startTransitionAnimation(clickedNoisyIndex) {
                if (isAnimating) return;
                clearAllHighlights(); // FIX: Clear any active highlights before starting animation
                isAnimating = true;
                isAnimationComplete = false;
                lastAnimatedIndex = clickedNoisyIndex;

                const n_frames = currentNFrames;
                const target_eff_idx = clickedNoisyIndex % n_frames;

                // --- Animate Main Graph ---
                const originalBoxData = boxesData.find(d => d.id === `q-${clickedNoisyIndex}`);
                const targetBoxData = boxesData.find(d => d.id === `q-${target_eff_idx}`);
                const translateX = targetBoxData.x - originalBoxData.x;
                
                linesGroup.selectAll('line.connection')
                    .transition().duration(FADE_DURATION)
                    .style('opacity', d => {
                        const fromQ = d.from_q;
                        const toK = d.to_k;
                        let keepLine = false;
                        if (are_connected_inference_anim(fromQ, toK, n_frames, target_eff_idx)) {
                            keepLine = true;
                        } else if ((fromQ < n_frames) && (toK < n_frames) && (fromQ % n_frames < target_eff_idx) && (toK % n_frames < target_eff_idx)) {
                            if (are_connected_training(fromQ, toK, n_frames)) {
                                keepLine = true;
                            }
                        }
                        return keepLine ? 0.8 : 0;
                    });
                
                d3.selectAll('#boxes-group rect, #labels-group foreignObject')
                    .transition().duration(FADE_DURATION).delay(STAGGER_DELAY)
                    .style('opacity', d => {
                        let keepBox = false;
                        if (d.index === clickedNoisyIndex) keepBox = true;
                        else if (d.isClean && d.eff_idx < target_eff_idx) keepBox = true;
                        return keepBox ? 1 : 0;
                    });
                
                d3.selectAll(`#q-${clickedNoisyIndex}, #k-${clickedNoisyIndex}, #label-q-${clickedNoisyIndex}, #label-k-${clickedNoisyIndex}`)
                    .transition().duration(MOVE_DURATION).delay(FADE_DURATION + STAGGER_DELAY)
                    .attr('transform', `translate(${translateX}, 0)`)
                    .on('end', () => {
                        isAnimating = false;
                        isAnimationComplete = true;
                    });
                
                linesGroup.selectAll('line.connection')
                    .filter(d => d.from_q === clickedNoisyIndex || d.to_k === clickedNoisyIndex)
                    .transition().duration(MOVE_DURATION).delay(FADE_DURATION + STAGGER_DELAY)
                    .attrTween('x1', function(d) {
                        if (d.from_q !== clickedNoisyIndex) return null;
                        const startX = parseFloat(d3.select(this).attr('x1'));
                        const endX = startX + translateX;
                        return d3.interpolate(startX, endX);
                    })
                    .attrTween('x2', function(d) {
                        if (d.to_k !== clickedNoisyIndex) return null;
                        const startX = parseFloat(d3.select(this).attr('x2'));
                        const endX = startX + translateX;
                        return d3.interpolate(startX, endX);
                    });

                // --- Animate Mask ---
                const indicesToKeep = new Set();
                boxesData.forEach(d => {
                    let keepBox = false;
                    if (d.index === clickedNoisyIndex) keepBox = true;
                    else if (d.isClean && d.eff_idx < target_eff_idx) keepBox = true;
                    if (keepBox) indicesToKeep.add(d.index);
                });

                maskGridGroup.selectAll('rect.mask-cell')
                    .transition().duration(FADE_DURATION)
                    .style('opacity', d => (indicesToKeep.has(d.q) && indicesToKeep.has(d.k)) ? 1 : 0);

                maskLabelsGroup.selectAll('.mask-tick')
                    .transition().duration(FADE_DURATION)
                    .style('opacity', d => indicesToKeep.has(d.index) ? 1 : 0)
                    .on('end', (d, i, nodes) => {
                        if (i !== nodes.length -1) return; // Run only once at the end
                        // Compact the remaining cells
                        const sortedKeptIndices = Array.from(indicesToKeep).sort((a, b) => a - b);
                        const newSize = sortedKeptIndices.length;
                        const newCellSize = MASK_GRID_SIZE / newSize;
                        const indexMap = new Map(sortedKeptIndices.map((oldIndex, newIndex) => [oldIndex, newIndex]));

                        maskGridGroup.selectAll('rect.mask-cell')
                            .filter(d => indicesToKeep.has(d.q) && indicesToKeep.has(d.k))
                            .transition().duration(MOVE_DURATION)
                            .attr('x', d => MASK_PADDING + MASK_LABEL_OFFSET + indexMap.get(d.k) * newCellSize)
                            .attr('y', d => MASK_PADDING + indexMap.get(d.q) * newCellSize)
                            .attr('width', newCellSize)
                            .attr('height', newCellSize);

                        maskLabelsGroup.selectAll('.mask-tick')
                            .filter(d => indicesToKeep.has(d.index))
                            .transition().duration(MOVE_DURATION)
                            .attr('height', newCellSize)
                            .attr('x', d => {
                                const newIndex = indexMap.get(d.index);
                                return d.type === 'k' ? MASK_PADDING + MASK_LABEL_OFFSET + newIndex * newCellSize + newCellSize / 2 - MASK_LABEL_OFFSET / 2 : MASK_PADDING;
                            })
                            .attr('y', d => {
                                const newIndex = indexMap.get(d.index);
                                return d.type === 'q' ? MASK_PADDING + newIndex * newCellSize : MASK_SVG_SIZE - MASK_PADDING - MASK_LABEL_OFFSET / 1.5;
                            });
                    });
            }

            function reverseTransitionAnimation() {
                if (isAnimating || lastAnimatedIndex === null) return;
                isAnimating = true;
                isAnimationComplete = false;
                
                // --- Animate Main Graph Back ---
                const currentLastAnimatedIndex = lastAnimatedIndex;
                d3.selectAll(`#q-${currentLastAnimatedIndex}, #k-${currentLastAnimatedIndex}, #label-q-${currentLastAnimatedIndex}, #label-k-${currentLastAnimatedIndex}`)
                    .transition().duration(MOVE_DURATION)
                    .attr('transform', `translate(${BOX_SIZE/2}, 0)`) 
                    .on('end', function() {
                        d3.select(this).attr('transform', null); 
                    });
                
                linesGroup.selectAll('line.connection')
                    .filter(d => d.from_q === currentLastAnimatedIndex || d.to_k === currentLastAnimatedIndex)
                    .transition().duration(MOVE_DURATION)
                    .attrTween('x1', function(d) {
                        if (d.from_q !== currentLastAnimatedIndex) return null;
                        const startX = parseFloat(d3.select(this).attr('x1'));
                        const endX = boxesData.find(b => b.id === `q-${d.from_q}`).x + BOX_SIZE;
                        return d3.interpolate(startX, endX);
                    })
                    .attrTween('x2', function(d) {
                        if (d.to_k !== currentLastAnimatedIndex) return null;
                        const startX = parseFloat(d3.select(this).attr('x2'));
                        const endX = boxesData.find(b => b.id === `k-${d.to_k}`).x + BOX_SIZE;
                        return d3.interpolate(startX, endX);
                    });

                d3.selectAll('#boxes-group rect, #labels-group foreignObject, #lines-group line')
                    .transition().duration(FADE_DURATION).delay(MOVE_DURATION - 200)
                    .style('opacity', d => (d && d.from_q !== undefined) ? 0.8 : 1)
                    .on('end', (d, i, nodes) => {
                        if (i === nodes.length - 1) {
                            isAnimating = false;
                            lastAnimatedIndex = null;
                            clearAllHighlights(); // FIX: Clear any lingering highlights after reset
                        }
                    });

                // --- Animate Mask Back ---
                drawMaskVisualization('training', { n_frames: currentNFrames });
            }

            // --- Event Handlers ---
            function handleBoxClick(event, d) {
                if (isAnimating || isAnimationComplete) return;
                if (d.type === 'q' && !d.isClean) {
                    startTransitionAnimation(d.index);
                }
            }
            
            function handleMouseOver(event, d) {
                if (isAnimating || isAnimationComplete) return;
                
                // Highlight connection lines in the main animation
                linesGroup.selectAll('line.connection').classed('dimmed', true);
                const lineSelector = d.type === 'q' ? `[data-from-q="${d.index}"]` : `[data-to-k="${d.index}"]`;
                linesGroup.selectAll(lineSelector).classed('dimmed', false).classed('highlighted', true).raise();

                // Highlight connected nodes in the main animation
                boxesGroup.selectAll('.box').classed('related-highlight', related_d => {
                    if (d.type === 'q') {
                        return related_d.type === 'k' && are_connected_training(d.index, related_d.index, currentNFrames);
                    } else { // d.type === 'k'
                        return related_d.type === 'q' && are_connected_training(related_d.index, d.index, currentNFrames);
                    }
                });

                // Highlight mask row OR column based on hover type
                if (d.type === 'q') {
                    maskGridGroup.selectAll('rect.mask-cell')
                        .filter(cell_d => cell_d.q === d.index)
                        .classed('highlighted', true);
                } else { // d.type === 'k'
                    maskGridGroup.selectAll('rect.mask-cell')
                        .filter(cell_d => cell_d.k === d.index)
                        .classed('highlighted', true);
                }
            }

            function handleMouseOut() {
                if (isAnimating || isAnimationComplete) return;
                clearAllHighlights();
            }

            function clearAllHighlights() {
                // Un-highlight all elements
                linesGroup.selectAll('line.connection').classed('dimmed', false).classed('highlighted', false);
                boxesGroup.selectAll('.box').classed('related-highlight', false);
                maskGridGroup.selectAll('rect.mask-cell').classed('highlighted', false);
            }

            function handleSvgResetClick(event) {
                if (event.target === svgAnim.node()) {
                    if (isAnimationComplete && !isAnimating) {
                        reverseTransitionAnimation();
                    }
                }
            }

            function typesetMathJax() {
                if (window.MathJax && MathJax.startup?.promise) {
                    MathJax.startup.promise.then(() => MathJax.typesetPromise());
                }
            }

            // --- Initial Setup and Event Listeners ---
            svgAnim.on('click', handleSvgResetClick);
            initializeVisualizations();
        });
    </script>
</body>
</html>