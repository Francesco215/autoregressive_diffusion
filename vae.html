<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deep Causal VAE Architecture</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            margin: 0;
            font-family: 'Inter', sans-serif;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: flex-start; 
            background-color: #f3f4f6;
            min-height: 100vh;
            padding: 2rem 0;
            box-sizing: border-box;
        }
        svg {
            user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;
            display: block;
        }
        rect.box {
            stroke: #9CA3AF;
            stroke-width: 1;
            cursor: pointer;
            transition: filter 0.2s ease-in-out, stroke 0.2s ease-in-out, stroke-width 0.2s ease-in-out;
        }
        /* Highlight Stroke Colors */
        rect.box.highlighted-l5, rect.box.highlighted-l4, rect.box.highlighted-l3,
        rect.box.highlighted-l2, rect.box.highlighted-l1, rect.box.highlighted-l0 { 
            filter: brightness(1.15); 
            stroke: #ef4444 !important; /* A single, strong highlight color for all nodes */
            stroke-width: 2 !important; 
        }
        
        line.connection {
            stroke-width: 1.5;
            transition: opacity 0.2s ease-in-out, stroke 0.2s ease-in-out, stroke-width 0.2s ease-in-out;
            opacity: 0.6;
        }

        .dimmed { opacity: 0.05 !important; }

        /* Highlighted Link Styles */
        line.connection.highlighted { 
            opacity: 1 !important; 
            stroke-width: 2.5 !important; 
            stroke: #ef4444 !important; /* A single, strong highlight color for all links */
        }
        line.connection.highlighted.cross-group {
             stroke: #F97316 !important; /* Special color for cross-group connections */
        }
    </style>
</head>
<body>
    <div class="w-full max-w-7xl p-4 text-center">
        <h1 id="viz-title" class="text-2xl font-bold mb-2 text-gray-700"></h1>
        <div class="flex justify-center mb-4">
            <button id="toggleButton" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition-colors">
                Switch to Causal
            </button>
        </div>
        <svg id="visualization" width="100%" class="bg-white rounded-lg shadow-md"></svg>
    </div>

    <script>
        const svg = d3.select('#visualization');
        const toggleButton = d3.select('#toggleButton');
        let isGroupCausal = true;

        const BOX_SIZE = 30;
        const BOX_SPACING = 15;
        const PADDING = 20;
        const N_FRAMES = 16;
        const L1_PARAMS = { KERNEL_T: 6, GROUP_SIZE: 4 };
        const L3_PARAMS = { KERNEL_T: 3, GROUP_SIZE: 2 };
        const L5_PARAMS = { KERNEL_T: 2, GROUP_SIZE: 1 };
        
        function getNodeColor(groupIndex) {
            const palette = [`hsl(210, 70%, 85%)`, `hsl(270, 70%, 85%)`, `hsl(30, 80%, 85%)`, `hsl(120, 70%, 85%)`]; // Blue, Purple, Orange, Green
            return palette[groupIndex % palette.length];
        }
        
        function getLinkColor(targetNode) {
            const palette = ['#3B82F6', '#A855F7', '#F97316', '#22C55E']; // Blue, Purple, Orange, Green
            return palette[targetNode.group % palette.length];
        }

        function are_connected_group_causal(t_in, t_out, G, kt) {
            const i_out = Math.floor((t_out - 1) / G);
            const group_start = i_out * G + 1;
            const lookback = Math.max(0, kt - G);
            const start_in = Math.max(1, group_start - lookback);
            const end_in = group_start + G - 1;
            return t_in >= start_in && t_in <= end_in;
        }

        function are_connected_causal(t_in, t_out, kt) {
            return t_in <= t_out && (t_out - t_in) < kt;
        }

        function drawVisualization() {
            svg.html('');
            
            d3.select('#viz-title').text(isGroupCausal ? 'Deep Group-Causal Architecture' : 'Deep Standard Causal Architecture');
            
            const rowSpacings = [50, 55, 65, 75, 85];
            const layerY = {};
            let currentY = PADDING;
            layerY.l5 = currentY;
            currentY += BOX_SIZE + rowSpacings[0]; layerY.l4 = currentY;
            currentY += BOX_SIZE + rowSpacings[1]; layerY.l3 = currentY;
            currentY += BOX_SIZE + rowSpacings[2]; layerY.l2 = currentY;
            currentY += BOX_SIZE + rowSpacings[3]; layerY.l1 = currentY;
            currentY += BOX_SIZE + rowSpacings[4]; layerY.l0 = currentY;

            const svgWidth = PADDING * 2 + N_FRAMES * BOX_SIZE + (N_FRAMES - 1) * BOX_SPACING;
            const svgHeight = currentY + BOX_SIZE + PADDING;
            svg.attr('viewBox', `0 0 ${svgWidth} ${svgHeight}`);

            const nodes = [];
            const addNodes = (count, type, group_size, y_pos, x_provider) => {
                for (let i = 1; i <= count; i++) {
                    nodes.push({ id: `${type}-${i}`, type, index: i, group: Math.floor((i-1)/group_size), x: x_provider(i), y: y_pos});
                }
            };

            // Assign groups to propagate colors up the hierarchy
            addNodes(N_FRAMES, 'l1', L1_PARAMS.GROUP_SIZE, layerY.l1, i => PADDING + (i-1)*(BOX_SIZE+BOX_SPACING));
            addNodes(N_FRAMES, 'l0', L1_PARAMS.GROUP_SIZE, layerY.l0, i => nodes.find(n=>n.id===`l1-${i}`).x);
            addNodes(N_FRAMES/2, 'l2', 2, layerY.l2, i => (nodes.find(n=>n.id===`l1-${2*i-1}`).x + nodes.find(n=>n.id===`l1-${2*i}`).x)/2);
            addNodes(N_FRAMES/2, 'l3', 2, layerY.l3, i => nodes.find(n=>n.id===`l2-${i}`).x);
            addNodes(N_FRAMES/4, 'l4', 1, layerY.l4, i => (nodes.find(n=>n.id===`l3-${2*i-1}`).x + nodes.find(n=>n.id===`l3-${2*i}`).x)/2);
            addNodes(N_FRAMES/4, 'l5', 1, layerY.l5, i => nodes.find(n=>n.id===`l4-${i}`).x);
            
            const linkDefs = [
                { from: 'l0', to: 'l1', count: N_FRAMES, params: L1_PARAMS, type: 'conv' },
                { from: 'l1', to: 'l2', count: N_FRAMES/2, type: 'downsample' },
                { from: 'l2', to: 'l3', count: N_FRAMES/2, params: L3_PARAMS, type: 'conv' },
                { from: 'l3', to: 'l4', count: N_FRAMES/4, type: 'downsample' },
                { from: 'l4', to: 'l5', count: N_FRAMES/4, params: L5_PARAMS, type: 'conv' }
            ];
            const allLinksFlat = linkDefs.flatMap(def => {
                const links = [];
                if (def.type === 'conv') {
                    const { KERNEL_T, GROUP_SIZE } = def.params;
                    const effective_kt = KERNEL_T - GROUP_SIZE + 1;
                    const rule = isGroupCausal ? (t_in, t_out) => are_connected_group_causal(t_in, t_out, GROUP_SIZE, KERNEL_T) : (t_in, t_out) => are_connected_causal(t_in, t_out, effective_kt);
                    for (let t_out = 1; t_out <= def.count; t_out++) {
                        for (let t_in = 1; t_in <= def.count; t_in++) {
                            if (rule(t_in, t_out)) links.push({ sourceId: `${def.from}-${t_in}`, targetId: `${def.to}-${t_out}` });
                        }
                    }
                } else {
                    for (let i = 1; i <= def.count; i++) {
                        links.push({ sourceId: `${def.from}-${2*i-1}`, targetId: `${def.to}-${i}` });
                        links.push({ sourceId: `${def.from}-${2*i}`, targetId: `${def.to}-${i}` });
                    }
                }
                return links;
            });

            const allLinks = allLinksFlat.map(l => ({...l, source: nodes.find(n=>n.id===l.sourceId), target: nodes.find(n=>n.id===l.targetId)}));
            
            const linksGroup = svg.append('g');
            const boxesGroup = svg.append('g');

            linksGroup.selectAll('line.connection')
                .data(allLinks, d => `${d.sourceId}-${d.targetId}`).join('line')
                .attr('class', d => `connection ${d.source.type}-link`)
                .attr('x1', d => d.source.x + BOX_SIZE / 2).attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x + BOX_SIZE / 2).attr('y2', d => d.target.y + BOX_SIZE)
                .style('stroke', d => getLinkColor(d.target));

            boxesGroup.selectAll('rect.box')
                .data(nodes, d => d.id).join('rect')
                .attr('class', 'box').attr('id', d => d.id)
                .attr('x', d => d.x).attr('y', d => d.y)
                .attr('width', BOX_SIZE).attr('height', BOX_SIZE).attr('rx', 4).attr('ry', 4)
                .style('fill', d => getNodeColor(d.group));

            boxesGroup.selectAll('rect.box').on('mouseover', function(event, d) {
                svg.selectAll('rect.box, line.connection').classed('dimmed', true);
                
                const pathIds = new Set();
                const queueDown = [d];
                const visitedDown = new Set([d.id]);
                while(queueDown.length > 0) {
                    const current = queueDown.shift();
                    pathIds.add(current.id);
                    allLinks.forEach(link => {
                        if (link.source.id === current.id && !visitedDown.has(link.target.id)) {
                            visitedDown.add(link.target.id);
                            queueDown.push(link.target);
                        }
                    });
                }

                const queueUp = [d];
                const visitedUp = new Set([d.id]);
                 while(queueUp.length > 0) {
                    const current = queueUp.shift();
                    pathIds.add(current.id);
                    allLinks.forEach(link => {
                        if (link.target.id === current.id && !visitedUp.has(link.source.id)) {
                            visitedUp.add(link.source.id);
                            queueUp.push(link.source);
                        }
                    });
                }
                
                svg.selectAll('rect.box')
                    .filter(node => pathIds.has(node.id))
                    .classed('dimmed', false)
                    .each(function(node) {
                        d3.select(this).classed(`highlighted-${node.type}`, true);
                    });
                
                linksGroup.selectAll('line.connection')
                    .filter(l => pathIds.has(l.source.id) && pathIds.has(l.target.id))
                    .classed('dimmed', false)
                    .classed('highlighted', true)
                    .classed('cross-group', l => l.source.type === 'l0' && l.source.group !== l.target.group);
            });

            boxesGroup.selectAll('rect.box').on('mouseleave', () => svg.selectAll('.dimmed, [class*="highlighted"]').attr('class', function() { return this.className.baseVal.replace(/\bhighlighted\S*|dimmed|cross-group/g, '').trim(); }));
        }

        toggleButton.on('click', () => { isGroupCausal = !isGroupCausal; toggleButton.text(isGroupCausal ? 'Switch to Causal' : 'Switch to Group-Causal'); drawVisualization(); });
        drawVisualization();
    </script>
</body>
</html>